import { area as d3Area, CurveFactory } from 'd3-shape';

import { getFirstItem, getSecondItem } from './getItem';
import { getScaledValueFactory } from './getScaledFactoryValue';
import { getStackValue } from './getStackValue';
import { isValidNumber } from './isValidNumber';
import { setNumberOrNumberAccessor } from './setNumberOrNumberAccessor';
import type { AxisScale, IDataEntry, ScaleSet, StackDatum } from './types';

export function createAreaStackPathShape<Datum extends object>({
  scales,
  dataEntry,
  horizontal,
  curve
}: {
  scales: ScaleSet;
  dataEntry: IDataEntry<Datum, StackDatum<AxisScale, AxisScale, Datum>>;
  horizontal: boolean;
  curve: CurveFactory;
  renderingOffset: number;
}): string {
  const getScaledIndependent = getScaledValueFactory<AxisScale, StackDatum<AxisScale, AxisScale, Datum>>(
    scales.independent,
    getStackValue
  );
  const getScaledDependent = getScaledValueFactory(scales.dependent, getFirstItem);
  const getScaledDependent0 = getScaledValueFactory(scales.dependent, getSecondItem);
  const isDefined = (d: StackDatum<AxisScale, AxisScale, Datum>) =>
    isValidNumber(scales.independent(getStackValue(d))) && isValidNumber(scales.dependent(getSecondItem(d)));
  const area = d3Area<StackDatum<AxisScale, AxisScale, Datum>>();
  area.defined(isDefined);
  area.curve(curve);
  setNumberOrNumberAccessor(horizontal ? area.y : area.x, getScaledIndependent);
  setNumberOrNumberAccessor(horizontal ? area.x0 : area.y0, getScaledDependent0);
  setNumberOrNumberAccessor(horizontal ? area.x1 : area.y1, getScaledDependent);
  return dataEntry.createShape(area) ?? '';
}
